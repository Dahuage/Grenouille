#0. ld究竟对对代码做了什么？ld中设置的地址意味着什么？
	编译以文件为单位，符号齐全就可以进行。
	链接对编译产生的文件进行组合并生成elf。
	ld中设置的地址意味着，最终可执行代码中的地址以设置的地址开始。
	还意味着要学习一下编译原理。

#1. elf究竟是什么。programme header确定了什么？
	elf就是可执行文件的协议。明确了可执行文件的元信息。
	各类header确定了可执行代码、静态数据等程序组成单元在在整个文件中的布局分布 
	确定从磁盘中相对于本文件的什么位置开始读？[确定程序段起点位置]
	读多少？[确定程序段的大小]
	加载到内存的什么位置？[确定加载位置]
	可执行文件的入口在哪儿？等问题。[确定入口地址]

#2. 内核究竟被加载到了哪里？按什么方式加载的？段？
	如问题#1所述，这些问题由elf决定。而elf取决于链接程序的行为。
	xv6、jos、ucore都被加载到了0x100000.而他们的加载程序bootloader则被bios加载在0x10000
	操作系统的img整体更像一个多级火箭。每一级都会被临时地写在内存中，用于推进内核升空。
	等完成各自的任务就会被丢弃。占用的内存也会被覆写。

			/\
		   /  \
		  /bios\        0xfffffff0-0xffffffff(mapped to eprom)
         /------\---------------------------------------------
        /        \
       /bootloader\               0x7c00-0x87c00
      |____________|__________________________________________
      |            |
      |            |
      | elf header |                               
      |            |
      |____________|
      |            |
      |            |
      | pro header |              0x10000-0x210000
      |            |
      |____________|
	  |            |
      |            |
      | elf ...... |
      |            |
      |____________|_________________________________________
      |            |
      |            |
      | kernel     |		      0x100000~
      |            |
      |____________|____________________________________________
      ^^^^^^^^^^^^^^

#3. 内核被加载完成后，内存的布局
	如问题#2所示。 0～0x100000将会保留給io映射，及中断向量。
	0x100000～0xffffffff随便用？

#4. xv6中何时开启了cr0.PG
	xv6中entry.S才是kernel的第一入口。在该入口中。
	手动地将entry函数的虚拟地址转换为物理地址。
	在此函数中，xv6开启了cr0的分页标志位。
	至此，ld中设置0x81000000全部得以映射。
	可以说，xv6开始就是页式内存管理。
